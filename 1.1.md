## 1.1 От классического программирования к квантовому: «Всё новое — это хорошо забытое старое!»

Первое предложение по квантовому программированию сделал Нил (Knill) в 1996 году [254]. Он представил модель **QRAM (Квантовая машина с произвольным доступом к памяти)** и предложил набор соглашений для написания псевдокода квантовых вычислений... В последние несколько лет произошёл быстрый прогресс, в основном обусловленный усилиями нескольких ИТ-гигантов по созданию квантового аппаратного обеспечения.

**Языки программирования и программные системы** — это огромная область компьютерных наук. Исследователи пытались расширить различные классические (традиционные) методологии и технологии программирования на квантовое программирование. Но квантовые вычисления — это новая вычислительная технология с фундаментальными изменениями на базовом уровне вычислительных моделей. Переход от классического программирования к квантовому можно описать фразой **«Всё новое — это хорошо забытое старое»** — название песни Питера Аллена, которую также использовал Джон Хеннесси в своей лекции при получении премии Тьюринга, описывая архитектуру компьютеров в эпоху ИИ.

В этом разделе мы кратко обсудим историю исследований квантового программирования и некоторые недавние работы. Я должен извиниться за то, что многие важные исследования здесь не упомянуты из-за ограниченности места и моих собственных знаний. Для ознакомления с двумя недавними обзорами по этой области мы отсылаем к [204, 449]. Также читатель может найти библиографию по квантовому программированию (поддерживаемую Kartik Singhal) на веб-странице: https://quantumpl.github.io/bib/.

### 1.1.1 Языки и компиляторы квантового программирования

Начальные исследования квантового программирования фокусировались на **разработке языков квантового программирования**. В конце 1990-х и начале 2000-х годов было определено несколько высокоуровневых языков квантового программирования:

*   **QCL:** Первый язык квантового программирования, создан Эмером (Ömer) [325]; он также реализовал симулятор для этого языка.
*   **qGCL:** ЯП в стиле защищенного командного языка  Дейкстры, предложен Сандерсом (Sanders) и Зулиани (Zuliani) [361, 455].
*   **Квантовое расширение C++:** Предложено Беттелли (Bettelli) и др. [60], реализовано в виде библиотеки C++.
*   **QPL:** Первый язык квантового программирования функциональной парадигмы, определён Селинджером (Selinger) [367] на основе идеи **классического управления и квантовых данных**.
*   **QML:**Квантовый язык программирования, подобный Haskell**, представлен Альтенкирхом (Altenkirch) и Грэттейдж (Grattage) 19]. Примечание: В отличие от QPL Селинджера, этот язык использует дублирование, а не отбрасывание квантовой информации как примитивную операцию. Также QML вводит как классические, так и квантовые операторы управления, в то время как большинство других языков полагаются на классическое управление.
*   **Квантовое расширение предикативного программирования:** Определено Тафлиовичем (Tafliovich) и Хенером (Hehner) [387, 388], поддерживает подход к разработке, при котором каждый шаг программирования сопровождается доказательством его корректности в момент выполнения. Примечание: Тафлиович и Хенер разработали теорию, которая позволяет: 
— записывать как классические, так и квантовые спецификации;
— создавать квантовые программы, реализующие эти спецификации;
— анализировать сравнительную временную и пространственную сложность квантовых и классических программ в единой рамках. 
Их работа основана на вероятностном предикативном программировании — обобщении традиционного предикативного программирования, учитывающем вероятностный характер квантовых вычислений

Эти ранние исследования сыграли важную роль в понимании фундаментальных различий между классическим и квантовым программированием [168, 203, 360, 368, 418].

**Вторая волна** исследований языков квантового программирования пришлась на начало 2010-х годов. Например:

*   **Quipper и Scaffold:** Два универсальных, масштабируемых языка с компиляторами, разработаны Грином (Green), Ламсдейном (Lumsdaine), Россом (Ross), Селинджером и Валироном (Valiron) [187] и Абхари (Abhari), Фаруке (Faruque), Дусти (Dousti) и др. [4] соответственно.
*   **QuaFL:** Предметно-ориентированный язык, разработан Лейпетсом (Lapets), да Силвой (da Silva), Тоуми (Thome), Адлером (Adler), Билом (Beal) и Рёттелером (Rötteler) [269].
*   **LIQUi|>:** Архитектура квантового ПО вместе с языком, встроенным в F#, спроектирована и реализована Векером (Wecker) и Своре (Svore) [405].
*   В этот период также проводились исследования архитектуры квантовых компьютеров [105, 298].

Стимулированные быстрым прогрессом в создании квантового оборудования с середины 2010-х годов, языки и компиляторы квантового программирования стали активно развивающейся областью исследований с акцентом на практическое прииенение. Было представлено много новых результатов: от наборов инструкций и промежуточных представлений (например, OpenQSAM [113], Quil [380], QIR [346]) до языков описания квантовых схем (например, QWIRE [332]), высокоуровневых языков и фреймворков (например, Q# [386], Quipper [187], Silq [63], Quingo [166]) и программных стеков (например, Qiskit [221], tket [347], Cirq [181], isQ [193]). Язык **Qunity** был спроектирован в [401] для трактовки квантовых вычислений как естественного обобщения классических. Также недавно Юанем (Yuan) и Карбином (Carbin) [447] в языки квантового программирования были введены **структуры данных**.

Похоже, что **эра NISQ (Noisy Intermediate-Scale Quantum** [342] продлится ещё некоторое время. В эту эру аппаратное обеспечение слишком ограничено в ресурсах, чтобы поддерживать коррекцию ошибок, и выполнение на нём длинных последовательностей операций непрактично. Поэтому особенно важной исследовательской темой является **оптимизация квантовых компиляторов** (см., например, [225, 299, 412]). Большая часть классического оптимизирующего компилятора нацелена на оптимизацию высокоуровневых конструкций программ (например, оптимизация циклов). Однако текущие исследования по оптимизации квантовых компиляторов в основном рассматривают оптимизацию квантовых схем, потому что на данный момент высокоуровневые конструкции программ не могут быть выполнены на квантовом оборудовании. 

### 1.1.2 Семантика и системы типов квантовых программ

**Формальная семантика** языка программирования даёт строгое математическое описание значения этого языка, позволяя точно и глубоко понять суть языка, скрытую под его синтаксисом. Операционная или денотационная семантика для некоторых ранних языков квантового программирования (например, qGCL, QPL и QML, упомянутых выше) была предоставлена уже при их определении [290].

Было предложено два подхода к семантике **семантике предикатных трансформеров** для квантовых программ:

1.  Первый был принят Сандерсом и Зулиани [361] при разработке qGCL, где квантовое вычисление сводится к вероятностному вычислению через процедуру наблюдения (измерения), и, таким образом, семантика предикатных трансформеров, разработанная для вероятностных программ [297], может быть применена к квантовым программам.
2.  Второй был представлен Д'Ондтом (D'Hondt) и Панангденом (Panangaden) [131], где квантовый предикат определяется как физическая наблюдаемая, представленная эрмитовым оператором с собственными значениями в единичном интервале. Семантика квантовых предикатных трансформеров была далее развита в [424] с использованием специального класса квантовых предикатов, а именно **проекционных операторов**. Фокус на проективных предикатах позволяет использовать богатые математические методы, разработанные в квантовой логике Биркгофа–фон Неймана [66], для установления различных условий корректности («оздоровительных условий») квантовых программ.

Семантические техники для квантовых вычислений также исследовались абстрактным, независимым от языка способом. Абрамски (Abramsky) и Кёкке (Coecke) [6] предложили **теоретико-категорную формулировку** основных постулатов квантовой механики, которая может быть использована для элегантного описания квантовых программ и протоколов связи, таких как телепортация. Недавний прогресс включает: Хасуо (Hasuo) и Хосино (Hoshino) [202] нашли семантическую модель функционального языка квантового программирования с рекурсией через **Geometry of Interaction** Жирара [177], сформулированную категорио Абрамски и др. [8, 68]. Пагани (Pagani), Селинджер и Валирон [329] открыли денотационную семантику для функционального языка квантового программирования с рекурсией и бесконечным типом данных, используя конструкции из количественной семантики линейной логики. Джейкобс (Jacobs) [226] предложил категориую аксиоматизацию блочных конструкций в квантовом программировании. Стейтон (Staton) [382] представил алгебраический семантический фреймворк для эквациональных рассуждений о квантовых программах.

В настоящее время семантические техники, разработанные в вышеупомянутых работах, широко применяются при определении различных языков квантового программирования. В этой книге мы формально определим операционную и денотационную семантику нескольких важных конструкций квантовых программ, включая последовательные, параллельные и распределённые квантовые программы, по мере их введения.

**Системы типов** широко используются в современных языках программирования для спецификации типов данных и уменьшения возможности ошибок, связанных с несоответствием типов. Некоторые языки квантового программирования также оснащены эффективными системами типов. Например, линейная зависимая система типов была определена Фу (Fu), Кишидой (Kishida) и Селинджером [164] для Quipper, линейная система типов была предоставлена Пейкиным (Paykin), Рэнд (Rand) и Здансевичем (Zdancewic) [332] для QWIRE, а система типов для Q# была предложена Сингхалом и др. [379]; одна из главных целей всех этих систем — **статически гарантировать соблюдение принципа запрета клонирования** для квантовых данных.

### 1.1.3 Верификация и анализ квантовых программ

Человеческая интуиция гораздо лучше адаптирована к классическому миру, чем к квантовому. Это означает, что программисты будут совершать гораздо больше ошибок при проектировании программ для квантовых компьютеров. Поэтому **крайне важно разрабатывать техники верификации для квантовых программ**.

Во-первых, различные **программные логики** были обобщены для квантовой среды. Например:

*   Балтаг (Baltag) и Сметс (Smets) [41] представили формализм динамической логики для информационных потоков в квантовых системах.
*   Брюне (Brunet) и Жоран (Jorrand) [79] ввели метод применения квантовой логики Биркгофа–фон Неймана для анализа квантовых программах.
*   Шадха (Chadha), Матеуш (Mateus) и Сернадаш (Sernadas) [85] предложили систему доказательств в стиле Флойда–Хоара для рассуждения об императивных квантовых программах, в которых допускаются только ограниченные итерации.
*   Некоторые полезные правила доказательства для рассуждения о квантовых программах были предложены Фэн (Feng) и др. [146] для чисто квантовых программ. В частности, в [419] была разработана (Флойда-)Хоара логика для частичной и тотальной корректности квантовых программ с (относительной) полнотой.

В последние несколько лет исследования в этой области сильно активизировались. Например, несколько квантовых расширений **реляционной логики Хоара** были предложены Унру (Unruh) [395], Барте (Barthe) и др. [48], а также Унру и Ли (Li) [274] для рассуждения о реляционных свойствах между двумя квантовыми программами и, в частности, для верификации безопасности квантовых криптографических протоколов. 
**Логика разделения (Separation logic)** была обобщена Чжоу (Zhou) и др. [451] и Ле (Le) и др. [270] для масштабируемой верификации квантовых программ. 
Квантовое расширение **логики некорректности (Incorrectness logic)** было предложено Яном (Yan), Цзянем (Jiang) и Юем (Yu) [414] для отладки квантовых программ. Для применения в текущую эру NISQ Хунг (Hung) и др. [219], Чжоу и др. [452], а также Тао (Tao) и др. [392] предложили некоторые правила доказательства для **анализа робастности** квантовых программ, выполняющихся на зашумлённых устройствах.

Несколько направлений исследований по верификации квантовых программ особенно важны для практических приложений:

1.  **Верификация квантовых компиляторов:** Включает VOQC — полностью верифицированный оптимизатор для квантовых схем, написанный в помощнике доказательств Coq Хиетала (Hietala) и др. [206, 207], и Giallar — полностью автоматизированный набор инструментов для верификации квантового компилятора qiskit от IBM, созданный Тао и др. [391].
2.  **Теоремы доказательств квантовой логики Хоара:** Реализованы в помощниках доказательств Isabelle/HOL Лю (Liu) и др. [281] и Coq Чжоу и др. [450], которые смогли проверить корректность некоторых сложных квантовых алгоритмов, например, поиска Гровера, алгоритма для скрытой подгруппы и HHL-алгоритма для решения систем линейных уравнений. Среда формальной верификации **Qbricks** была разработана в [87] для предметно-ориентированного языка построения схем Qbricks-DSL с использованием языка логических спецификаций Qbricks-Spec и гибридной квантовой логики Хоара.

Читатель может найти больше обсуждений верификации квантовых программ в двух недавних обзорах [88, 271].

**Техники анализа программ** очень полезны при реализации и оптимизации программ. Исследования по анализу квантовых программ велись по следующим направлениям:

1.  **Инварианты:** Понятие инварианта для квантовых программ было определено в [432], где также представлен SDP-алгоритм (Semi-Definite Programming) для генерации инвариантов квантовых программ в пространствах состояний конечной размерности.
2.  **Анализ завершимости (Termination):** Инициирован в [426], где рассматривался квантовый цикл, основанный на измерении, с унитарным преобразованием в качестве тела цикла. Завершимость более общего квантового цикла с квантовой операцией в качестве тела цикла изучалась в [435] с использованием семантической модели квантовых марковских цепей. В [435] также было показано, что метод Шарира–Пнуэли–Харта (Sharir–Pnueli–Hart) для доказательства свойств вероятностных программ [375] может быть элегантно обобщён на квантовые программы, используя дуальность Шрёдингера–Гейзенберга между квантовыми состояниями и наблюдаемыми. Эта линия исследований была продолжена в [275, 277, 439, 440, 444], где изучалась завершимость недетерминированных и конкурентных квантовых программ на основе анализа достижимости квантовых марковских процессов принятия решений. Другой подход к анализу завершимости через синтез **функций ранжирования** был обобщён на квантовые программы в [276].
3.  **Анализ времени выполнения:** Ожидаемое время выполнения квантовых циклов `while` впервые изучалось в [435]. Анализ времени выполнения квантовых программ был реализован ДжавадиАбхари (JavadiAbhari) и др. [230] в фреймворке квантовой компиляции ScaffCC. Исчисление слабейших предусловий для рассуждений об ожидаемом времени выполнения квантовых программ было разработано Ольмедо (Olmedo) и Диас-Каро (Díaz-Caro) [324], а также Лю и др. [282]. Другие ресурсы для выполнения квантовых программ также рассматривались; например, оценка необходимых кубитов и квантовых вентилей для атаки алгоритмом Шора на ECC (эллиптическую криптографию) была дана Рёттелером и др. [356]. Символьный метод для оценки ресурсов был представлен Меули (Meuli) и др. [268, 299] для точного квантового компилятора.
4.  **Абстрактная интерпретация:** Впервые использована Жораном (Jorrand) и Пердриксом (Perdrix) [236] для анализа квантовых программ. Недавно в этом направлении было представлено несколько интересных идей. Чтобы смягчить проблему экспоненциального взрыва размерности пространства состояний, Юй (Yu) и Палсберг (Palsberg) [443] предложили использовать кортеж (низкоразмерных) проекций в качестве абстракции (высокоразмерного) квантового состояния. Тесная связь между абстрактной интерпретацией, квантовой логикой Хоара и квантовой логикой некорректности была обнаружена Фэн и Ли (Li) [151].
5.  **Утверждения времени выполнения (Runtime assertions):** Было предложено несколько схем утверждений времени выполнения для отладки, тестирования и смягчения ошибок квантовых программ, включая статистические утверждения Хуанга (Huang) и Мартоноси (Martonosi) [218], утверждения, использующие swap-тест Лю, Бёрда (Byrd) и Чжоу [279, 280], и утверждения на основе проекций Ли и др. [273].
6.  **Уникальные проблемы анализа:** Все вышеперечисленные техники анализа являются квантовыми обобщениями соответствующих техник, используемых в классическом программировании. Но есть несколько уникальных проблем в анализе квантовых программ. В частности, анализ **запутанности** между переменными программы был введён ДжавадиАбхари и др. [230] в квантовом компиляторе ScaffCC. Совсем недавно метод анализа запутанности в квантовых программах был предложен Юанем, МакНелли (McNally) и Карбином [446] через исследование чистоты квантовых состояний запутанной подсистемы.