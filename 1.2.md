## 1.2 Подходы к квантовому программированию

Естественно, что исследования в области квантового программирования начались с расширения классических (традиционных) моделей, методологий и технологий программирования на квантовую область. Как кратко рассмотрено в разделе 1.1, парадигмы императивного и функционального программирования были обобщены для квантовых вычислений, а различные семантические модели, методы верификации и анализа классических программ также были адаптированы для квантового программирования.

В этом разделе мы подумаем о квантовом программировании под другим углом. **Конечная цель квантового программирования — в полной мере использовать возможности квантовых компьютеров.** Вопрос в том, как мы можем достичь этой цели, разрабатывая эффективные модели квантового программирования и создавая подходящие языки квантового программирования?

Чтобы ответить на этот вопрос, начнем с понимания роли языков программирования.

Языки программирования были определены Сэти (Sethi) [373] как **нотации, которые используются для спецификации, организации и анализа вычислений**. Он предположил, что разработчики языков должны находить баланс между:

*   **обеспечением удобства для людей**, и
*   **эффективным использованием вычислительных машин**;

и подчеркнул, что **удобство важнее**; без него эффективность не имеет значения.

Роль языков программирования в организации и анализе вычислений также отражена в следующем отрывке из лекции Айверсона, получившего премию Тьюринга ACM в 1979 году [229]:

> **Цитата Айверсона:**
> *«Конструкции, доступные в языке, определяют то, как мы „думаем“ и „рассуждаем“ о реализованных алгоритмах. Поэтому выбор языка программирования влияет на то, как мы концептуализируем проблему».*

Теперь давайте рассмотрим, как определить язык программирования, который может правильно специфицировать, организовывать и обосновывать квантовые вычисления.
Хорошо известно, что преимущество квантовых компьютеров перед современными компьютерами проистекает из **квантового параллелизма** — суперпозиции квантовых состояний — и его производных, таких как запутанность. Итак, ключевой вопрос в квантовом программировании: **как включить квантовый параллелизм в классические (традиционные) модели программирования?**

### 1.2.1 Классическое параллельное программирование

Чтобы решить поднятый выше вопрос, давайте сначала вспомним некоторые основные идеи классического параллельного программирования из стандартного учебника [278].

Параллелизм — это фундаментальная техника в классических вычислениях, используемая на разных уровнях — от инструкций до систем — для ускорения вычислений.

Классический параллелизм обычно можно разделить на два следующих класса:

*   **Параллелизм данных (Data parallelism):** выполнение одной и той же операции, скажем \( P \), над разными элементами данных, скажем \( d_1, ..., d_n \), в одно и то же время.
*   **Параллелизм задач (Task parallelism):** выполнение различных вычислений (или задач), скажем \( P_1, ..., P_n \), в одно и то же время.

Конечно, многие вычисления являются гибридами двух вышеуказанных видов параллелизма. Соответственно, вводятся два класса классических параллельных программ:

*   **Параллелизм данных** удобно описывать с помощью оператора `forall`:
    ```
    forall (⟨variable⟩) in (⟨range specification⟩)
    {
        ⟨body⟩
    }
    ```
    с семантикой: `спецификация диапазона` оценивается как множество данных (set D = {d1, ..., dn} of data). Тогда каждый d∈D оответствует логическому потоку (thread), обозначаемому P [d], который выполняет копию кода `body` с `переменной`, равной d.

*   **Параллелизм задач** можно правильно записать как параллельную композицию: P1||···||Pn. (1.2)

Здесь P1, …, Pn представляют собой n различных задач, и они могут разделять переменные (и память).

**Основная идея для введения квантового параллелизма в классические модели программирования** проистекает из **трансляции между параллелизмом данных и параллелизмом задач**. Чтобы представить её формально, нам нужны некоторые обозначения из GCL (Guarded Command Language — язык охраняемых команд) Дейкстры [132].

Напомним, что условный оператор может быть записан как:
```
if b then S₁ else S₀ fi(1.3)
```
где b — булево выражение. Это означает, что когда b истинно, будет выполняться подпрограмма S1; в противном случае будет выполняться S0. В более общем смысле, **оператор выбора (case statement)** представляет собой набор защищённых команд:
```
if ( □i · Gi → Si ) fi (1.4)
```
где для каждого 1 ≤ i ≤ n , подпрограмма Si охраняется булевым  Gi, и Si будет выполнена только когда Gi истинно.

Используя GCL Дейкстры, мы можем формально показать, как параллелизм данных и задач могут быть переведены друг в друга:

*   **Параллелизм данных** можно рассматривать как параллелизм задач (1.2) со следующим определением:
```
Pi ≡ x := di ; P[x]
для каждого i = 1, …, n.
```

*   **Обратно**, параллелизм задач (1.2) может быть реализован как параллелизм данных (1.1) путём введения индексной переменной i:
```
forall i in {1, ..., n} P[i]    (1.5)
```
где:
```
P[i] ≡ if (□ d ∈ D · i = d → Pd)fi ≡ if i = 1 → P1
                                      □ i = 2 → P2
                                             ······
                                      □ i = n → Pn    (1.6)
                                     fi
```
Как мы увидим в следующем подразделе, это простое наблюдение может послужить **мостом от классического параллелизма к квантовому параллелизму**.

### 1.2.2 Суперпозиция данных против суперпозиции программ

Теперь мы готовы представить два различных способа включения квантового параллелизма в традиционные модели программирования, а именно две парадигмы суперпозиции:

#### **Суперпозиция данных (Superposition-of-data) – квантовые программы с классическим управлением**

Основная идея парадигмы **суперпозиции данных** состоит во введении новых программных конструкций, необходимых для манипулирования квантовыми данными, например, унитарных преобразований, квантовых измерений. Однако **потоки управления** (control flows) квантовых программ в такой парадигме аналогичны потокам управления классических программ.

Например, в классическом программировании базовой программной конструкцией, которая может использоваться для определения потока управления, является условный оператор или, в более общем смысле, оператор выбора. Отметим, что **недетерминизм** возникает в операторе выбора как следствие «перекрытия» охраняющих выражений 'G1, G2, ..., Gn;'  то есть если более чем одно Gi истинно одновременно, оператору выбора нужно выбрать для выполнения одну из соответствующих команд Si. В частности, если 'G1 = G2 = ··· = Gn = true', то оператор выбора превращается в **демонический выбор**:

$$\square_{i=1}^n S_i$$   

где альтернативы Si выбираются непредсказуемо. В вероятностном расширении GCL Дейкстры — **pGCL (probabilistic Guarded Command Language)** [297] — недетерминизм уточняется с помощью **вероятностного выбора**:

$$\square_{i=1}^n S_i \ @p_i$$

где \( \{p_i\} \) — это распределение вероятностей; то есть \( p_i \ge 0 \) для всех \( i \), и \( \sum_{i=1}^n p_i = 1 \). Эта конструкция случайным образом выбирает команду Si с вероятностью \( p_i \) для каждого  i . Это можно рассматривать как разрешение демонического выбора.

Принимая во внимание статистическую природу квантовых измерений, комбинация идей оператора выбора и вероятностного выбора даёт нам **оператор выбора, основанный на измерении (measurement-based case statement)**:
\[
\text{if } ( \square_{i} \cdot M[q] = m_i \rightarrow P_i ) \text{ fi}
\]
где \( q \) — квантовая переменная, а \( M \) — измерение, выполняемое над \( q \) с возможными исходами \( m_1, ..., m_n \), и для каждого \( i \), \( P_i \) — это (квантовая) подпрограмма. Этот оператор выбирает команду в соответствии с результатом измерения \( M \): если исход \( m_i \), то будет выполняться соответствующая команда \( P_i \). Его можно уместно назвать **классическим оператором выбора в квантовом программировании**, потому что выбор команд в нём основан на классической информации — результатах квантового измерения. Очевидно, что это естественное квантовое расширение классического оператора выбора. Другие языковые механизмы, используемые для спецификации потока управления квантовых программ, например, циклы и рекурсия, могут быть определены на основе этого оператора выбора.

Описанная выше парадигма программирования называется **парадигмой суперпозиции данных**, потому что данные, вводимые в эти программы и вычисляемые ими, являются квантовыми данными (суперпозицией данных), но сами программы не могут находиться в суперпозиции. Эта парадигма может быть ещё более чётко охарактеризована слоганом Селинджера (Selinger) **«квантовые данные, классическое управление» (quantum data, classical control)** [367], поскольку потоки данных программ являются квантовыми, но их потоки управления остаются классическими.

Большинство существующих исследований по квантовому программированию было выполнено в парадигме суперпозиции данных, имея дело с квантовыми программами с классическим управлением. Теоретический фундамент этой парадигмы будет разработан в Частях II и III этой книги.

#### **Суперпозиция программ (Superposition-of-programs) – квантовые программы с квантовым управлением**

Вторая парадигма квантового программирования, рассматриваемая в этом подразделе, изначально была вдохновлена построением квантовых блужданий [11, 24]. В работах [433, 434] было замечено, что существует **фундаментально иной способ определения оператора выбора в квантовом программировании — квантовый оператор выбора (quantum case statement)**, управляемый квантовой «монетой»:
\[
\text{qif}[c] \left( \square_{i} \cdot |i\rangle \rightarrow P_i \right) \text{fiq}
\]
где \( \{|i\rangle\} \) — это ортонормированный базис гильбертова пространства состояний внешней системы-«монеты» \( c \), и выбор подпрограмм \( P_i \) осуществляется в соответствии с базисными состояниями \( |i\rangle \) пространства «монеты», которые могут находиться в суперпозиции и, следовательно, являются **квантовой информацией**, а не классической.

Более того, мы можем определить **квантовый выбор (quantum choice)**:
\[
\left[ C \right] \ \bigodot_{i} \ |i\rangle \rightarrow P_i \ \triangleq \ C[c]; \ \text{qif}[c] \left( \square_{i} \cdot |i\rangle \rightarrow P_i \right) \text{fiq}
\]

Интуитивно, квантовый выбор запускает программу «подбрасывания монеты» \( C \) для создания суперпозиции путей выполнения подпрограмм \( P_1, ..., P_n \), за которой следует квантовый оператор выбора. Во время выполнения квантового оператора выбора каждая \( P_i \) выполняется вдоль своего собственного пути внутри общей суперпозиции путей выполнения \( P_1, ..., P_n \). На основе такого рода квантового оператора выбора и квантового выбора могут быть определены некоторые новые конструкции квантовых программ, такие как **квантовая рекурсия**.

Здесь самое время заметить интересную связь между классическим и квантовым параллелизмом. Если мы внимательно сравним эти выражения с выражением для классического параллелизма задач, преобразованного в параллелизм данных, мы увидим, что квантовый оператор выбора и квантовый выбор — это, по сути, **квантовая версия параллелизма задач**. Как мы увидим позже в книге, понятие квантового параллелизма задач часто даёт интуитивный способ мышления и рассуждения о квантовых алгоритмах.

Описанный выше подход к квантовому программированию можно назвать **парадигмой суперпозиции программ**. Из определений квантового оператора выбора и квантового выбора ясно, что поток управления квантовой программы в парадигме суперпозиции программ является **изначально квантовым (inherently quantum)**. Таким образом, эту парадигму можно также охарактеризовать слоганом **«квантовые данные, квантовое управление» (quantum data, quantum control)**.¹

Теоретические вопросы этой парадигмы будут обсуждаться в Части V этой книги. Но я должен признать, что эта парадигма всё ещё находится на самой ранней стадии развития, и серия фундаментальных проблем ещё недостаточно изучена. С другой стороны, я считаю, что она вводит **новый способ мышления о квантовом программировании**, который может помочь программисту в дальнейшем использовании уникальной мощи квантовых вычислений.
